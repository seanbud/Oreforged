"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const dom_fiber_testing_library_1 = require("@react-facet/dom-fiber-testing-library");
const useFacetWrapMemo_1 = require("./useFacetWrapMemo");
const useFacetEffect_1 = require("./useFacetEffect");
const useFacetMap_1 = require("./useFacetMap");
const facet_1 = require("../facet");
const types_1 = require("../types");
it('wraps a value, updating the facet when it changes', () => {
    const mock = jest.fn();
    const ComponentWithFacetEffect = ({ value }) => {
        const facetifiedValue = (0, useFacetWrapMemo_1.useFacetWrapMemo)(value);
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            mock(value);
        }, [], [facetifiedValue]);
        return react_1.default.createElement("span", null);
    };
    const dom = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, { value: "value" }));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('value');
    mock.mockClear();
    dom.rerender(react_1.default.createElement(ComponentWithFacetEffect, { value: "changed" }));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('changed');
});
it('wraps a value, with the default equality check (preventing unnecessary updates)', () => {
    const mock = jest.fn();
    const ComponentWithFacetEffect = ({ value }) => {
        const facetifiedValue = (0, useFacetWrapMemo_1.useFacetWrapMemo)(value);
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            mock(value);
        }, [], [facetifiedValue]);
        return react_1.default.createElement("span", null);
    };
    const dom = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, { value: "value" }));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('value');
    mock.mockClear();
    dom.rerender(react_1.default.createElement(ComponentWithFacetEffect, { value: "value" }));
    expect(mock).toHaveBeenCalledTimes(0);
});
it('forwards a facet', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'value' });
    const mock = jest.fn();
    const ComponentWithFacetEffect = () => {
        const facetifiedValue = (0, useFacetWrapMemo_1.useFacetWrapMemo)(demoFacet);
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            mock(value);
        }, [], [facetifiedValue]);
        return react_1.default.createElement("span", null);
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('value');
    mock.mockClear();
    demoFacet.set('changed');
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('changed');
});
it('forwards a facet with NO_VAUE', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: types_1.NO_VALUE });
    const mock = jest.fn();
    const ComponentWithFacetEffect = () => {
        const facetifiedValue = (0, useFacetWrapMemo_1.useFacetWrapMemo)(demoFacet);
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            mock(value);
        }, [], [facetifiedValue]);
        return react_1.default.createElement("span", null);
    };
    // On first render, it should not call the effect, as the wrapped facet has no value
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
    expect(mock).not.toHaveBeenCalled();
    mock.mockClear();
    demoFacet.set('changed');
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('changed');
});
it('updates correctly if the facet instance change (ex: via a useFacetMap)', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'value' });
    const TestingComponent = ({ concat }) => {
        // When a dependency of useFacetMap change (concat) a new facet is created
        // And when we pass that to the useFacetWrapMemo we need to make sure that it gets propagated
        return (react_1.default.createElement("span", null,
            react_1.default.createElement("fast-text", { text: (0, useFacetWrapMemo_1.useFacetWrapMemo)((0, useFacetMap_1.useFacetMap)((value) => `${value} ${concat}`, [concat], [demoFacet])) })));
    };
    const { container, rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestingComponent, { concat: "123" }));
    expect(container).toHaveTextContent('value 123');
    rerender(react_1.default.createElement(TestingComponent, { concat: "456" }));
    expect(container).toHaveTextContent('value 456');
});
describe('regressions', () => {
    it('should not immediately call a function when wrapped', () => {
        const mock = jest.fn();
        const TestingComponent = () => {
            const handlerFacet = (0, useFacetWrapMemo_1.useFacetWrapMemo)(mock);
            (0, useFacetEffect_1.useFacetEffect)(() => undefined, [], [handlerFacet]);
            return null;
        };
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestingComponent, null));
        expect(mock).toHaveBeenCalledTimes(0);
    });
});
const testEffectUpdatesOnStaticValue = (value, expectUpdates) => {
    const mock = jest.fn();
    const TestingComponent = () => {
        const undefinedFacet = (0, useFacetWrapMemo_1.useFacetWrapMemo)(value);
        (0, useFacetEffect_1.useFacetEffect)(() => {
            mock();
        }, [], [undefinedFacet]);
        return null;
    };
    const { rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestingComponent, null));
    expect(mock).toHaveBeenCalledTimes(1);
    rerender(react_1.default.createElement(TestingComponent, null));
    if (expectUpdates) {
        expect(mock).toHaveBeenCalledTimes(2);
    }
    else {
        expect(mock).toHaveBeenCalledTimes(1);
    }
    rerender(react_1.default.createElement(TestingComponent, null));
    if (expectUpdates) {
        expect(mock).toHaveBeenCalledTimes(3);
    }
    else {
        expect(mock).toHaveBeenCalledTimes(1);
    }
};
describe('does not trigger effect updates on re-renders for the same value', () => {
    it('string', () => {
        testEffectUpdatesOnStaticValue('', false);
        testEffectUpdatesOnStaticValue('test', false);
    });
    it('boolean', () => {
        testEffectUpdatesOnStaticValue(false, false);
        testEffectUpdatesOnStaticValue(true, false);
    });
    it('number', () => {
        testEffectUpdatesOnStaticValue(0, false);
        testEffectUpdatesOnStaticValue(1, false);
    });
    it('undefined', () => {
        testEffectUpdatesOnStaticValue(undefined, false);
    });
    it('null', () => {
        testEffectUpdatesOnStaticValue(null, false);
    });
    it('empty array', () => {
        testEffectUpdatesOnStaticValue([], false);
    });
    it('filled array', () => {
        testEffectUpdatesOnStaticValue(['string', 1], false);
    });
    it('empty object', () => {
        testEffectUpdatesOnStaticValue({}, false);
    });
    it('filled object', () => {
        testEffectUpdatesOnStaticValue({ key: 'value' }, false);
    });
});
it('allows changing the equality check', () => {
    const mock = jest.fn();
    const ComponentWithFacetEffect = ({ value, equalityCheck, }) => {
        const facetValue = (0, useFacetWrapMemo_1.useFacetWrapMemo)(value, equalityCheck);
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            mock(value);
        }, [], [facetValue]);
        return react_1.default.createElement("span", null);
    };
    const alwaysFalse = () => () => false;
    const dom = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, { value: "value" }));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('value');
    mock.mockClear();
    // as we change the equality check, it should re-initialize the inline facet, causing an update
    dom.rerender(react_1.default.createElement(ComponentWithFacetEffect, { value: "value", equalityCheck: alwaysFalse }));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('value');
});
//# sourceMappingURL=useFacetWrapMemo.spec.js.map