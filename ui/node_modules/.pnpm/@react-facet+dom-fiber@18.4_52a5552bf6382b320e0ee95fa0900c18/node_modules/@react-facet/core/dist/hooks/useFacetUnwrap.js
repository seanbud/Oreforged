"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFacetUnwrap = void 0;
const react_1 = require("react");
const types_1 = require("../types");
const equalityChecks_1 = require("../equalityChecks");
/**
 * Hook that allows consuming values from a Facet
 * It acts as a regular react state, triggering a re-render of the component
 *
 * @param facet
 */
function useFacetUnwrap(prop, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    const initializationCleanup = (0, react_1.useMemo)(() => {
        if (!(0, types_1.isFacet)(prop))
            return () => { };
        return prop.observe(() => { });
    }, [prop]);
    const [state, setState] = (0, react_1.useState)(() => {
        if (!(0, types_1.isFacet)(prop))
            return { value: prop };
        return {
            value: prop.get(),
        };
    });
    // Creates a ref, and keep it updated (used for equality check within the effect)
    const previousStateRef = (0, react_1.useRef)(state);
    previousStateRef.current = state;
    (0, react_1.useLayoutEffect)(() => {
        if ((0, types_1.isFacet)(prop)) {
            // Initialize the equalityCheck
            const isEqual = equalityCheck();
            const startValue = prop.get();
            if (startValue !== types_1.NO_VALUE) {
                isEqual(startValue);
            }
            const cleanup = prop.observe((value) => {
                const { value: previousValue } = previousStateRef.current;
                /**
                 * Performs this equality check locally to prevent triggering two consecutive renderings
                 * for facets that have immutable values (unfortunately we can't handle mutable values).
                 *
                 * The two renderings might happen for the same state value if the Facet has a value on mount.
                 *
                 * The unwrap will get the value:
                 * - Once on initialization of the useState above
                 * - And another time on this observe initialization
                 */
                if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
                    const typeofValue = typeof previousValue;
                    if ((typeofValue === 'number' ||
                        typeofValue === 'string' ||
                        typeofValue === 'boolean' ||
                        value === undefined ||
                        value === null) &&
                        value === previousValue) {
                        return;
                    }
                    // Even though we set the previous ref in the render (which should be triggered by
                    // the setState), the setState re-render is delayed until all of the .set changes are
                    // flushed. So we update the previous ref here to provide the correct value for subsequent
                    // runs.
                    // As an example:
                    //    useEffect(() => {
                    //      myFacet.set(true)
                    //      myFacet.set(false)
                    //    }, [])
                    // This would flush both sets before the setState below causes a re-render to update the ref.
                    // The line below fixes the above scenario.
                    previousStateRef.current = { value };
                    return setState({ value });
                }
                if (previousValue !== types_1.NO_VALUE && isEqual(value)) {
                    return;
                }
                return setState({ value });
            });
            initializationCleanup();
            return cleanup;
        }
    }, [prop, equalityCheck, initializationCleanup]);
    return (0, types_1.isFacet)(prop) ? state.value : prop;
}
exports.useFacetUnwrap = useFacetUnwrap;
//# sourceMappingURL=useFacetUnwrap.js.map