import { Facet, ExtractFacetValues, NoValue } from '../types';
/**
 * Creates a callback that depends on the value of a facet.
 * Very similar to `useCallback` from `React`
 *
 * @param callback function callback that receives the current facet values and the arguments passed to the callback
 * @param dependencies variable used by the callback that are available in scope (similar as dependencies of useCallback)
 * @param facets facets that the callback listens to
 * @param defaultReturnValue a default value to be returned by the callback, if the facets don't have any value yet
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 */
export declare function useFacetCallback<M, Y extends Facet<unknown>[], T extends [...Y], K extends [...unknown[]]>(callback: (...args: ExtractFacetValues<T>) => (...args: K) => M, dependencies: unknown[], facets: T, defaultReturnValue: M): (...args: K) => M;
/**
 * Creates a callback that depends on the value of a facet.
 * Very similar to `useCallback` from `React`
 *
 * @param callback function callback that receives the current facet values and the arguments passed to the callback
 * @param dependencies variable used by the callback that are available in scope (similar as dependencies of useCallback)
 * @param facets facets that the callback listens to
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 *
 * **NOTE:** useFacetCallback does NOT change reference when it's facet dependencies change, so it will not trigger updates for
 * any hook that depends on it. If you depend on that a useFacetCallback will re-trigger a downstream hook when it's facet value updates, that will not happen.
 *
 * Suggested solution is to turn the facet callback into a normal callback that accepts the values of the facets as parameters, then put
 * the facets you depend on as parameters to your useFacet-Hook that is used further downstream.
 */
export declare function useFacetCallback<M, Y extends Facet<unknown>[], T extends [...Y], K extends [...unknown[]]>(callback: (...args: ExtractFacetValues<T>) => (...args: K) => M, dependencies: unknown[], facets: T): (...args: K) => M | NoValue;
